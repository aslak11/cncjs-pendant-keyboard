#!/usr/bin/env node

var fs = require('fs');
var path = require('path');
var program = require('commander');
var serialport = require('serialport');
var inquirer = require('inquirer');
var pkg = require('../package.json');
var serverMain = require('../index');
var hid = require("node-hid");
var options = {};

program
	.version(pkg.version)
	.usage('-s <secret> -p <port> [options]')
	.option('-l, --list', 'list available ports then exit')
    .option('-s, --secret', 'the secret key stored in the ~/.cncrc file')
	.option('-p, --port <port>', 'path or name of serial port')
	.option('-b, --baudrate <baudrate>', 'baud rate (default: 115200)', 115200)
	.option('--socket-address <address>', 'socket address or hostname (default: localhost)', 'localhost')
	.option('--socket-port <port>', 'socket port (default: 8000)', 8000)
	.option('--controller-type <type>', 'controller type: Grbl|Smoothie|TinyG|Marlin (default: Marlin)', 'Marlin')
    .option('--access-token-lifetime <lifetime>', 'access token lifetime in seconds or a time span string (default: 30d)', '30d')

program.parse(process.argv);

var options = {
    secret: program.secret,
    port: program.port,
    baudrate: program.baudrate,
    socketAddress: program.socketAddress,
    socketPort: program.socketPort,
    controllerType: program.controllerType,
    accessTokenLifetime: program.accessTokenLifetime
};

if (options.list) {
	serialport.list(function(err, ports) {
		if (err) {
			console.error(err);
			process.exit(1);
		}
		ports.forEach(function(port) {
			console.log(port.comName);
		});
	});
	return;
}

var store = {
    controller: {
        state: {},
        settings: {}
    },
    sender: {
        status: {}
    }
};

var kbdevent = {
    l_control : 0,
    l_shift : 0,
    l_alt : 0,
    l_meta : 0,
    r_control: 0,
    r_shift : 0,
    r_alt : 0,
    r_meta : 0,
    key : 0,                // Normal keys
    extra : 0,              // Advanced Keys or Special Keys
    repeating: 0,           // If it is repating a movement
    can_repeat : 1,         // If can repeat
    move: 1,                // Actually move size
    default_move: 1         // Alter by F1, F2, F3
};

var createServer = function(options) {
    serverMain(options, function(err, socket) {
        // Grbl
        socket.on('Grbl:state', function(state) {
            store.controller.state = state;
        });
        socket.on('Grbl:settings', function(settings) {
            store.controller.settings = settings;
        });

        // Smoothie
        socket.on('Smoothie:state', function(state) {
            store.controller.state = state;
        });
        socket.on('Smoothie:settings', function(settings) {
            store.controller.settings = settings;
        });

        // TinyG
        socket.on('TinyG:state', function(state) {
            store.controller.state = state;
        });
        socket.on('TinyG:settings', function(settings) {
            store.controller.settings = settings;
        });

        // Marlin
        socket.on('Marlin:state', function(state) {
            store.controller.state = state;
        });
        socket.on('Marlin:settings', function(settings) {
            store.controller.settings = settings;
        });
        
        // Sender
        socket.on('sender:status', function(data) {
            store.sender.status = data;
        });

        var keyboard_main = new hid.HID('/dev/hidraw0');
        var keyboard_extra = new hid.HID('/dev/hidraw1');

        var tool_diameter = 6;

        keyboard_main.on("data", function(data) {
            var recv = data.toJSON().data;
            var bits = recv.shift();
            kbdevent.l_control = ((bits & 1) !== 0);
            kbdevent.l_shift = ((bits & 2) !== 0);
            kbdevent.l_alt = ((bits & 4) !== 0);
            kbdevent.l_meta = ((bits & 8) !== 0);
            kbdevent.r_control = ((bits & 16) !== 0);
            kbdevent.r_shift = ((bits & 32) !== 0);
            kbdevent.r_alt = ((bits & 64) !== 0);
            kbdevent.r_meta = ((bits & 128) !== 0);
            recv.shift();
            kbdevent.key = recv.shift();
            kbdevent.repeating = 0;
            sendToController();
        })

        keyboard_extra.on("data", function(data) {
            var recv = data.toJSON().data;
            recv.shift();
            kbdevent.extra = recv.shift();
            kbdevent.repeating = 0;
            sendToController();
        })

        function sendToController() {
            // Calculate move size modifiers
            kbdevent.move = kbdevent.default_move;
            if (kbdevent.l_alt || kbdevent.r_alt) {
                kbdevent.move=0.1;
            } else if (kbdevent.l_shift || kbdevent.r_shift || kbdevent.r_meta) {
                kbdevent.move=10;
            }

            // Process pressed key
            switch (kbdevent.extra) {
                case 234:       // vol+
                    relativeMovement("Z", "down", kbdevent.move);
                    break;
                case 233:       // vol-
                    relativeMovement("Z", "up", kbdevent.move);
                    break;
                case 131:       // Media: Play (Top corner left)
                    socket.emit('write', options.port, "M106 P0\n");
                    break;
                case 226:       // Mute (Top corner left)
                    socket.emit('write', options.port, "M107\n");
                    break;
                case 148:       // Key: Home -> Goto Zero-working position
                    if(!kbdevent.l_shift) {
                        socket.emit('write', options.port, "G90\n");
                        socket.emit('write', options.port, "G00 X0 Y0 Z0\n");
                    } else {
                        socket.emit('write', options.port, "G28 Y X\n");
                    }
                    break;
                case 205:       // Key: Play/Pause
                    socket.emit('write', options.port, (kbdevent.l_meta ? "M108\n" : "M0\n"));
                    break;
                default:
                    break;
            }

            switch (kbdevent.key) {
                case 80:            // arrow: left
                    relativeMovement("X", "left", kbdevent.move);
                    break;
                case 79:            // arrow: right
                    relativeMovement("X", "right", kbdevent.move);
                    break;
                case 82:            // arrow: up
                    relativeMovement("Y", "up", kbdevent.move);
                    break;
                case 81:            // arrow: down
                    relativeMovement("Y", "down", kbdevent.move);
                    break;
                case 58:            // key: F1
                    kbdevent.default_move = 0.1
                    break;
                case 59:            // key: F2
                    kbdevent.default_move = 1
                    break;
                case 60:            // key: F3
                    kbdevent.default_move = 10
                    break;
                case 40:            // Key: OK or Enter
                    kbdevent.can_repeat = kbdevent.can_repeat ? 0 : 1;
                    break;
                case 78:            // Key: Page down
                    socket.emit('write', options.port, "G28 Z\n");
                    socket.emit('write', options.port, "G92 Z2\n");
                    socket.emit('write', options.port, "G00 Z5\n");
                    break;
                case 75:            // Key: Page up
                    break;
                case 27:            // Key: X
                    var offset = -(tool_diameter/2 + 2)
                    socket.emit('write', options.port, "G38.2 X700\n");
                    socket.emit('write', options.port, "G92 X" + offset + "\n");
                    break;
                case 28:            // Key: Y
                    var offset = -(tool_diameter/2 + 2)
                    socket.emit('write', options.port, "G38.2 Y700\n");
                    socket.emit('write', options.port, "G92 Y" + offset + "\n");
                    break;
                default:
                    break;
            }

            switch (true) {
                case (kbdevent.key > 30) && (kbdevent.key < 41) :
                    tool_diameter = kbdevent.key - 30 + 1
                    socket.emit('write', options.port, "M117 Tool dia: "+ tool_diameter + "mm\n");
                default:
                    break;
            }

            if ((kbdevent.extra || kbdevent.key) && kbdevent.can_repeat &&
                    kbdevent.key != 40 &&           // Key: Enter / OK -- change repeat function
                    kbdevent.extra != 148           // Special Key: Home -- goto Zero-working position
                ) {
                if (!kbdevent.repeating) {
                    kbdevent.repeating = 1;
                    setTimeout(sendToController, 1000);
                } else {
                    setTimeout(sendToController, 100);
                }
            } else {
                kbdevent.repeating = 0;
            }

            console.log(kbdevent)
        }

        function relativeMovement(axis, direction, move) {
            socket.emit('write', options.port, "G91\n");
            socket.emit('write', options.port, "G00 " + axis + (direction == "left" || direction == "down" ? "-" : "") + move + "\n");
            socket.emit('write', options.port, "G90\n");
        }

    });
};

// console.log('List of connected devices (paths): ');
// console.log('devices:', hid.devices());

if (options.port) {
    createServer(options);
    return;
}

serialport.list(function(err, ports) {
    if (err) {
        console.error(err);
        process.exit(1);
    }
    const choices = ports.map(function(port) {
        return port.comName;
    });

    inquirer.prompt([{
        type: 'list',
        name: 'port',
        message: 'Specify which port you want to use?',
        choices: choices
    }]).then(function(answers) {
        options.port = answers.port;

        createServer(options);
    });
});
